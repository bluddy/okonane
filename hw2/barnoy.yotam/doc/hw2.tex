\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{hyperref} 
\usepackage{enumerate}
%\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{fixltx2e}  % fixes that \( \) are fragile

\oddsidemargin 0mm
\evensidemargin 5mm
\topmargin -20mm
\textheight 240mm
\textwidth 160mm



\pagestyle{myheadings} 
\markboth{Homework 1}{Artificial Intelligence: Homework 1} 


\title{Artificial Intelligence: Homework 2}
\author{Yotam Barnoy}
\date{}

\usetikzlibrary{arrows}
\begin{document}
\large
\maketitle
\thispagestyle{headings}

\vspace{-.5in}

\begin{enumerate}
	\item My results are:

		\begin{table}[h]
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			Max Depth & \( 4 \times 4 \) Minimax & \( 4 \times 4 \) \( \alpha \beta \) & \( 6 \times 6 \) Minimax & \( 6 \times 6 \) \( \alpha \beta \) & \( 8 \times 8 \) Minimax & \( 8 \times 8 \) \( \alpha \beta \) \\ \hline
			% 4  m     ab  |6     m      ab | 8     m      ab |
			1 &  10  & 9   &     58 &    64 &     174 &   174 \\ \hline
			2 &  27  & 33  &    501 &   325 &    2446 &  1194 \\ \hline
			3 &  63  & 29  &   3013 &  1420 &   19970 &  5684 \\ \hline
			4 &  153 & 45  &  21332 &  4591 &  142491 & 22321 \\ \hline
			5 &  370 & 80  & 157159 & 24396 &   0     &   0   \\ \hline
			6 &  735 & 166 & 550525 & 57560 &	 	0     &   0   \\ \hline
		\end{tabular}
		\end{table}

	At depth 5 and 6, $8\times8$ Minimax and $\alpha\beta$ took too long.

\item My results:
	\begin{enumerate}	
		\item 
			$4 \times 4$ board, max depth 8: \\
	 \begin{table}[h]
		 \centering
		 \begin{tabular}{|c|c|c|c|c|}
			 \hline
			 Turn & Minimax nodes & \( \alpha\beta \) nodes & Minimax time & \( \alpha\beta \) time \\ \hline
			 %   mn   abn    mt     abt
			 1 & 4361 & 629  & 33.4ms & 8ms      \\ \hline
			 2 & 797  & 6    &  5ms   & 18us     \\ \hline
			 3 & 868  & 76   &  3.5ms & 0.3ms    \\ \hline
			 4 & 1478 & 4    & 5.4ms  & 16us     \\ \hline
			 5 & 393  & 114  & 1ms    & 0.3ms    \\ \hline
			 6 & 468  & 2    & 1.1ms  & 9us      \\ \hline

		\end{tabular}
	\end{table}

\newpage
\item $6 \times 6$ board, max depth 6: \\
	 \begin{table}[h]
		 \centering
		 \begin{tabular}{|c|c|c|c|c|}
			 \hline
			 Turn & Minimax nodes & \( \alpha\beta \) nodes & Minimax time & \( \alpha\beta \) time \\ \hline
			 %   mn       abn       mt     abt
			 1 & 5061   & 981   &  137ms & 25ms     \\ \hline
			 2 & 13353  & 3047  &  600ms & 118ms    \\ \hline
			 3 & 29581  & 2745  &  1.4s  & 129ms    \\ \hline
			 4 & 73467  & 10137 &  5.1s  & 590ms    \\ \hline
			 5 & 73020  & 7718  &  4.8s  & 494ms    \\ \hline
			 6 & 61771  & 5804  &  3.7s  & 317ms    \\ \hline
			 7 & 100156 & 7858  &  6.1s  & 431ms    \\ \hline
			 8 & 56062  & 6666  &  2.2s  & 228ms    \\ \hline
			 9 & 44212  & 6852  &  1.5s  & 234ms    \\ \hline
			10 & 116578 & 10686 &  4s    & 345ms    \\ \hline
			11 & 135347 & 15359 &  4.8s  & 530ms    \\ \hline
			12 & 72379  & 5790  &  1.9s  & 134ms    \\ \hline
			13 & 85094  & 9145  &  2s    & 198ms    \\ \hline
			14 & 72315  & 6320  &  1.7s  & 121ms    \\ \hline
	\ldots & \ldots & \ldots& \ldots & \ldots   \\ \hline
			25 & 30     & 4     &  108us & 70us     \\ \hline
			26 &  8     & 3     &  27us  & 10us     \\ \hline
		\end{tabular}
	\end{table}

\newpage

\item $8 \times 8$ board, max depth 4: \\
	 \begin{table}[h]
		 \centering
		 \begin{tabular}{|c|c|c|c|c|}
			 \hline
			 Turn & Minimax nodes & \( \alpha\beta \) nodes & Minimax time & \( \alpha\beta \) time \\ \hline
			 %   mn     abn    mt     abt
			 1 & 217   & 37   & 10ms   & 1.6ms    \\ \hline
			 2 & 31    & 28   & 1.3ms  & 0.4ms    \\ \hline
			 3 & 59    & 39   & 1.4ms  & 1.1ms    \\ \hline
			 4 & 269   & 149  & 10ms   & 5.6ms    \\ \hline
			 5 & 561   & 193  & 28ms   & 8ms      \\ \hline
			 6 & 1352  & 324  & 157ms  & 28ms     \\ \hline
			 7 & 3351  & 495  & 557ms  & 47.7ms   \\ \hline
			 8 & 7365  & 1418 & 3.8s   & 438ms    \\ \hline
			 9 & 9522  & 1196 & 4.9s   & 248ms    \\ \hline
			10 & 8745  & 1948 & 7.6s   & 1.1s     \\ \hline
			11 & 12172 & 1563 & 5.2s   & 413ms    \\ \hline
		  12 & 8018  & 1565 & 2.2s   & 305ms    \\ \hline
			13 & 12463 & 3116 & 8s     & 1s       \\ \hline
			14 & 10167 & 1564 & 5.2s   & 449ms    \\ \hline
	\ldots & \ldots & \ldots& \ldots & \ldots   \\ \hline
			20 & 19044 & 2533 & 10.7s  & 1.4s     \\ \hline
	\ldots & \ldots & \ldots& \ldots & \ldots   \\ \hline
			45 &  47   &  3   &  0.4ms & 19us     \\ \hline
			46 &  2    &  4   &  11us  & 27us     \\ \hline
		\end{tabular}
	\end{table}

\end{enumerate}

\item As the tables show, $\alpha\beta$'s optimizations becomes more effective and important as one tackles a bigger tree. Searching through a bigger board, a deeper maximum depth, or closer to the beginning -- all of these factors contribute to having a bigger state tree, and $\alpha\beta$'s advantage over Minimax becomes more pronounced. 

	At the start of a game of Konane, the branching factor is very low for the first two moves. This means that given a set maximum depth, both algorithms will search through smaller trees and $\alpha\beta$'s advantage will be minimized. Towards the end of the game, the options narrow down and the tree is small again, making the differences between the algorithms small. It's at the mid-game that you see the real difference between the two algorithms.

\item My board evaluation function finds the number of moves for the player about to play. It then reduces those moves to sets of non-conflicting (orthogonal) moves, ie. moves that don't overlap each other by either using the same piece or the same spaces. It takes the largest possible number of orthogonal moves, the total number of pieces of the player's color, and multiplies each of these values by a weight, giving the greatest weight to the number of orthogonal moves, a lesser weight to pieces, and an even less weight to the total number of moves.

	I then execute each opponent move and evaluate the same scoring function for the opponent, taking the minimum score. Finally, I substract the opponent's score from the player's score.

\item I spent much of my time iterating through evaluation functions. The first thing I noticed was that in a $4\times4$ board, both AIs know that black is about to lose, though that isn't really apparent from looking at the board. Certainly the difference in material doesn't seem to be such a major factor -- I saw games where one side had a material advantage, only to lose later on. 

	Since the game is about which side runs out of moves first, it seemed only logical that a good measure of the state of the board is comparing the number of moves each side had available. This was the first evaluation function I implemented. Except that this didn't really seem to capture the real essence of the game. What matters is not how many moves one has at any particular point, but how many independent mobile pieces one has: if I move a piece that competes with another of my pieces for an opponent piece or for a final destination, then I just cancelled out the other move. So what really matters is the number of independent, orthogonal moves that each side has.

	At the same time, having more pieces than my opponent, or having more optional moves than my opponent, seems like it should count for something. It should count for less than orthogonal moves (which I give a utility of 60), but these things could still be an advantage, all other things being equal. This is why assign lower utility values to material advantage and a number-of-moves advantage (20 and 2, respectively). 

	I implemented 2 versions of my heuristic: fast and slow. The slow version does exactly what is described in the previous answer: playing each move and finding the minimal opponent score, then subtracting it from the player score. The fast version of the heuristic gets the player's score, and then it pretends that the opponent is playing the same board (ie. without moving any pieces first). This is less accurate than the slow version: the opponent will never get to play that exact board, but since it's a heuristic anyway, it probably doesn't make such a big difference.

	Performance-wise, I probably became more worried about the performance than I needed to be. I tried to improve the expansion function since it's run so many times, but I forgot that I had been running in ocaml's bytecode mode, which is much slower than its native compilation mode. Native compilation proved to be much faster.

\item 11. Player 1 has no weakly dominant strategy, though $z$ weakly dominates $y$. Player 2 has $p$ as a weakly dominant strategy.

\item 12. Player 1 has $x$ as a strongly dominant strategy. Player 2 has no strongly dominant strategy.

\item 13. There are Nash equilibria at $(x,p)$ and $(x, r)$. 

\item 14. Player 1 has no weakly dominant strategy. Player 2 has no weakly dominant strategy.

\item 15. Player 1 has no strongly dominant strategy. Player 2 has no strongly dominant strategy.

\item 16. There are Nash equilibria at $(x,p)$ and at $(y,s)$.
\end{enumerate}

\end{document}

